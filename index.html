<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Dog Runner</title>
  <style>
    html, body { margin:0; padding:0; background:transparent; overflow:hidden; width:100%; height:100%; }
    img {
      position: absolute;
      bottom: -3px;
      right: -200px; /* commence hors écran à droite */
      height: 200px;
      animation: none; /* animation contrôlée par JS */
    }
    img.running {
      animation: run-back 5s linear;
    }
    img.walking {
      animation: walk-to-position 3s linear;
    }
    img.sitting {
      /* Position statique quand assis */
      position: absolute;
    }
    @keyframes run-back {
      0% { right: -200px; }
      100% { right: 100vw; }
    }
    @keyframes walk-to-position {
      /* Animation dynamique définie par JS */
    }
  </style>
</head>
<body>
  <img id="dog" src="assets/Spike_course_gauche.gif" alt="Chien courant">
  
  <script>
    const dog = document.getElementById('dog');
    let currentTimeout = null;
    let isInteractiveMode = false;
    let currentState = 'idle';
    let currentPosition = { right: -200 };

    // États possibles et leurs GIFs par direction
    const states = {
      course_gauche: 'assets/Spike_course_gauche.gif',
      course_droite: 'assets/Spike_course_droite.gif',
      marche_gauche: 'assets/Spike_marche_gauche.gif',
      marche_droite: 'assets/Spike_marche_droite.gif',
      assis_droit: 'assets/Spike_assi_droit.gif',
      assis_respi: 'assets/Spike_assi_droit_respi.gif'
    };

    // Fonction pour obtenir le bon GIF selon la direction
    function getDirectionalGif(baseState, fromPosition, toPosition) {
      if (baseState === 'assis_droit' || baseState === 'assis_respi') {
        return states[baseState]; // Les états assis n'ont pas de direction
      }
      
      // Détermine la direction : si toPosition > fromPosition, va vers la gauche
      const direction = toPosition > fromPosition ? 'gauche' : 'droite';
      return states[`${baseState}_${direction}`];
    }

    // Règles de transition (utilise les noms de base, la direction sera ajoutée dynamiquement)
    const transitions = {
      course: ['marche', 'course'],
      marche: ['assis_respi', 'assis_droit', 'course'],
      assis_droit: ['marche', 'assis_respi'],
      assis_respi: ['assis_droit', 'marche']
    };

    // Constantes de vitesse (pixels/seconde)
    const RUNNING_SPEED = 400; // vitesse de course
    const WALKING_SPEED = 100; // vitesse de marche

    // Utilitaires
    function getRandomDuration() {
      return Math.random() * (15000 - 2000) + 2000; // 2-15 secondes (pour les états assis)
    }

    function getRandomPosition() {
      const windowWidth = window.innerWidth;
      const dogWidth = 200; // largeur approximative du chien
      const margin = 50; // marge pour éviter les bords
      return Math.random() * (windowWidth - dogWidth - 2 * margin) + margin;
    }

    function calculateAnimationDuration(fromPosition, toPosition, speed) {
      const distance = Math.abs(toPosition - fromPosition);
      return distance / speed * 1000; // en millisecondes
    }

    function getCurrentDirection() {
      // Détermine la direction actuelle basée sur l'état et le GIF
      if (currentState.includes('_droite')) return 'droite';
      if (currentState.includes('_gauche')) return 'gauche';
      return 'gauche'; // par défaut
    }

    function getTargetDirection(fromPosition, toPosition) {
      // Détermine la direction vers laquelle on veut aller
      return toPosition > fromPosition ? 'gauche' : 'droite';
    }

    function needsDirectionChange(currentDirection, targetDirection) {
      // Vérifie si un changement de direction est nécessaire
      return currentDirection !== targetDirection;
    }

    function createTurnAroundAnimation(intermediatePosition, animationName = 'turn-around') {
      const duration = 500; // 0.5 seconde fixe pour les demi-tours
      
      const keyframes = `
        @keyframes ${animationName} {
          0% { right: ${currentPosition.right}px; }
          100% { right: ${intermediatePosition}px; }
        }
      `;
      
      // Supprime l'ancienne règle d'animation de demi-tour
      const oldStyle = document.querySelector(`#${animationName}-style`);
      if (oldStyle) oldStyle.remove();
      
      // Ajoute la nouvelle règle
      const style = document.createElement('style');
      style.id = `${animationName}-style`;
      style.textContent = keyframes;
      document.head.appendChild(style);
      
      return duration;
    }

    function changeState(newState, fromPosition = null, toPosition = null) {
      currentState = newState;
      
      if (fromPosition !== null && toPosition !== null) {
        dog.src = getDirectionalGif(newState, fromPosition, toPosition);
      } else {
        // Pour les états statiques ou quand on n'a pas les positions
        if (states[newState]) {
          // État exact trouvé (ex: assis_droit)
          dog.src = states[newState];
        } else {
          // Essaie avec _gauche par défaut pour les états de mouvement
          dog.src = states[`${newState}_gauche`] || states.course_gauche;
        }
      }
      
      console.log(`État changé vers: ${newState}, GIF: ${dog.src}`);
    }

    function getNextState(currentState) {
      // Utilise le nom de base de l'état (sans direction)
      const baseState = currentState.replace(/_gauche|_droite/, '');
      const possibleStates = transitions[baseState];
      return possibleStates[Math.floor(Math.random() * possibleStates.length)];
    }

    function createWalkAnimation(targetPosition, speed = WALKING_SPEED) {
      const duration = calculateAnimationDuration(currentPosition.right, targetPosition, speed);
      
      const keyframes = `
        @keyframes walk-to-position {
          0% { right: ${currentPosition.right}px; }
          100% { right: ${targetPosition}px; }
        }
      `;
      
      // Supprime l'ancienne règle d'animation
      const oldStyle = document.querySelector('#dynamic-walk-style');
      if (oldStyle) oldStyle.remove();
      
      // Ajoute la nouvelle règle
      const style = document.createElement('style');
      style.id = 'dynamic-walk-style';
      style.textContent = keyframes;
      document.head.appendChild(style);
      
      return duration; // Retourne la durée calculée
    }

    function createRunAnimation(targetPosition, speed = RUNNING_SPEED) {
      const duration = calculateAnimationDuration(currentPosition.right, targetPosition, speed);
      
      const keyframes = `
        @keyframes run-to-position {
          0% { right: ${currentPosition.right}px; }
          100% { right: ${targetPosition}px; }
        }
      `;
      
      console.log(`Animation course: de right=${currentPosition.right}px vers right=${targetPosition}px`);
      console.log(`Mouvement visuel: ${currentPosition.right < targetPosition ? 'va vers la GAUCHE' : 'va vers la DROITE'}`);
      
      // Supprime l'ancienne règle d'animation
      const oldStyle = document.querySelector('#dynamic-course-style');
      if (oldStyle) oldStyle.remove();
      
      // Ajoute la nouvelle règle
      const style = document.createElement('style');
      style.id = 'dynamic-course-style';
      style.textContent = keyframes;
      document.head.appendChild(style);
      
      return duration; // Retourne la durée calculée
    }

    // Fonction pour gérer les transitions avec demi-tours
    function executeMovementWithTurning(targetState, targetPosition, callback) {
      const currentDirection = getCurrentDirection();
      const targetDirection = getTargetDirection(currentPosition.right, targetPosition);
      const currentBaseState = currentState.replace(/_gauche|_droite/, '');
      
      console.log(`Mouvement: ${currentBaseState}_${currentDirection} vers ${targetState}_${targetDirection}`);
      
      // Si on est assis, on doit toujours faire une transition
      if (currentBaseState === 'assis_droit' || currentBaseState === 'assis_respi') {
        console.log('Transition depuis état assis, demi-tour nécessaire !');
        executeTurnAroundSequence(targetState, targetPosition, currentDirection, targetDirection, callback);
      } else if (!needsDirectionChange(currentDirection, targetDirection)) {
        // Pas de changement de direction nécessaire, mouvement direct
        executeDirectMovement(targetState, targetPosition, callback);
      } else {
        // Changement de direction nécessaire, faire le demi-tour
        console.log('Demi-tour nécessaire !');
        executeTurnAroundSequence(targetState, targetPosition, currentDirection, targetDirection, callback);
      }
    }

    function executeDirectMovement(targetState, targetPosition, callback) {
      if (targetState === 'marche') {
        const movementDuration = createWalkAnimation(targetPosition);
        
        dog.classList.remove('running', 'sitting');
        dog.classList.add('walking');
        changeState(targetState, currentPosition.right, targetPosition);
        
        dog.style.animation = `walk-to-position ${movementDuration / 1000}s linear`;
        
        setTimeout(() => {
          dog.classList.remove('walking');
          dog.style.animation = 'none';
          currentPosition.right = targetPosition;
          dog.style.right = `${targetPosition}px`;
          callback();
        }, movementDuration);
        
      } else if (targetState === 'course') {
        const movementDuration = createRunAnimation(targetPosition);
        
        dog.classList.remove('walking', 'sitting');
        dog.classList.add('running');
        changeState(targetState, currentPosition.right, targetPosition);
        
        dog.style.animation = `run-to-position ${movementDuration / 1000}s linear`;
        
        setTimeout(() => {
          dog.classList.remove('running');
          dog.style.animation = 'none';
          currentPosition.right = targetPosition;
          dog.style.right = `${targetPosition}px`;
          callback();
        }, movementDuration);
      }
    }

    function executeTurnAroundSequence(targetState, targetPosition, currentDirection, targetDirection, callback) {
      const currentBaseState = currentState.replace(/_gauche|_droite/, '');
      
      if (currentBaseState === 'course') {
        // Course -> Course avec demi-tour : course_dir1 -> marche_dir1 (0.5s) -> marche_dir2 (0.5s) -> course_dir2
        executeCourseToCourseTurn(targetState, targetPosition, currentDirection, targetDirection, callback);
      } else if (currentBaseState === 'marche') {
        if (targetState === 'course') {
          // Marche -> Course avec demi-tour : marche_dir1 -> marche_dir2 (0.5s) -> course_dir2
          executeMarcheToCourse(targetPosition, targetDirection, callback);
        } else {
          // Marche -> Marche avec demi-tour : marche_dir1 -> marche_dir2 (0.5s) -> continuer marche_dir2
          executeMarcheToMarche(targetPosition, targetDirection, callback);
        }
      } else if (currentBaseState === 'assis_droit' || currentBaseState === 'assis_respi') {
        // États assis -> mouvement : d'abord se lever en marche, puis continuer
        executeAssisToCourse(targetState, targetPosition, targetDirection, callback);
      }
    }

    function executeCourseToCourseTurn(targetState, targetPosition, currentDirection, targetDirection, callback) {
      // Phase 1: Ralentir à la marche dans la direction actuelle (0.5s)
      const intermediatePos1 = currentPosition.right + (currentDirection === 'gauche' ? 50 : -50);
      const duration1 = createTurnAroundAnimation(intermediatePos1, 'turn-phase1');
      
      dog.classList.remove('running', 'sitting');
      dog.classList.add('walking');
      changeState('marche', currentPosition.right, intermediatePos1);
      dog.style.animation = 'turn-phase1 0.5s linear';
      
      setTimeout(() => {
        currentPosition.right = intermediatePos1;
        
        // Phase 2: Marcher dans la direction opposée (0.5s)
        const intermediatePos2 = intermediatePos1 + (targetDirection === 'gauche' ? 50 : -50);
        const duration2 = createTurnAroundAnimation(intermediatePos2, 'turn-phase2');
        
        changeState('marche', intermediatePos1, intermediatePos2);
        dog.style.animation = 'turn-phase2 0.5s linear';
        
        setTimeout(() => {
          currentPosition.right = intermediatePos2;
          dog.style.animation = 'none';
          
          // Phase 3: Accélérer vers la course jusqu'à la position finale
          executeDirectMovement(targetState, targetPosition, callback);
        }, 500);
      }, 500);
    }

    function executeMarcheToCourse(targetPosition, targetDirection, callback) {
      // Marche -> Course : marche_dir1 -> marche_dir2 (0.5s) -> course_dir2
      const intermediatePos = currentPosition.right + (targetDirection === 'gauche' ? 50 : -50);
      const duration = createTurnAroundAnimation(intermediatePos, 'marche-turn');
      
      changeState('marche', currentPosition.right, intermediatePos);
      dog.style.animation = 'marche-turn 0.5s linear';
      
      setTimeout(() => {
        currentPosition.right = intermediatePos;
        dog.style.animation = 'none';
        
        // Maintenant course vers la position finale
        executeDirectMovement('course', targetPosition, callback);
      }, 500);
    }

    function executeMarcheToMarche(targetPosition, targetDirection, callback) {
      // Marche -> Marche : marche_dir1 -> marche_dir2 (0.5s) -> continuer vers position finale
      const intermediatePos = currentPosition.right + (targetDirection === 'gauche' ? 50 : -50);
      const duration = createTurnAroundAnimation(intermediatePos, 'marche-to-marche');
      
      changeState('marche', currentPosition.right, intermediatePos);
      dog.style.animation = 'marche-to-marche 0.5s linear';
      
      setTimeout(() => {
        currentPosition.right = intermediatePos;
        dog.style.animation = 'none';
        
        // Continuer la marche vers la position finale
        executeDirectMovement('marche', targetPosition, callback);
      }, 500);
    }

    function executeAssisToCourse(targetState, targetPosition, targetDirection, callback) {
      // États assis -> mouvement : d'abord marcher dans la bonne direction (0.5s), puis continuer
      const intermediatePos = currentPosition.right + (targetDirection === 'gauche' ? 50 : -50);
      const duration = createTurnAroundAnimation(intermediatePos, 'assis-to-move');
      
      dog.classList.remove('running', 'sitting');
      dog.classList.add('walking');
      changeState('marche', currentPosition.right, intermediatePos);
      dog.style.animation = 'assis-to-move 0.5s linear';
      
      setTimeout(() => {
        currentPosition.right = intermediatePos;
        dog.style.animation = 'none';
        
        // Maintenant continuer vers l'état et position finaux
        executeDirectMovement(targetState, targetPosition, callback);
      }, 500);
    }

    // Mode automatique (actuel)
    function startAutomaticAnimation() {
      if (isInteractiveMode) return;
      
      dog.classList.remove('walking', 'sitting');
      dog.classList.add('running');
      
      // Course de droite à gauche (toujours vers la gauche)
      const fromPos = -200;
      const toPos = window.innerWidth + 200;
      const duration = calculateAnimationDuration(fromPos, toPos, RUNNING_SPEED);
      
      changeState('course', fromPos, toPos);
      currentPosition.right = fromPos;
      
      setTimeout(() => {
        dog.classList.remove('running');
        currentPosition.right = toPos;
        scheduleNextAnimation();
      }, duration);
    }

    function scheduleNextAnimation() {
      if (isInteractiveMode) return;
      
      if (currentTimeout) {
        clearTimeout(currentTimeout);
      }
      
      const minDelay = 10 * 60 * 1000; // 10 minutes
      const maxDelay = 15 * 60 * 1000; // 15 minutes
      const randomDelay = Math.random() * (maxDelay - minDelay) + minDelay;
      
      console.log(`Prochaine animation dans ${Math.round(randomDelay / 60000)} minutes`);
      
      currentTimeout = setTimeout(() => {
        startAutomaticAnimation();
      }, randomDelay);
    }

    // Mode interactif "Viens ici"
    function startInteractiveSequence() {
      isInteractiveMode = true;
      
      if (currentTimeout) {
        clearTimeout(currentTimeout);
      }
      
      // Phase 1: Course vers une position aléatoire
      dog.classList.remove('walking', 'sitting');
      dog.classList.add('running');
      
      // IMPORTANT: Pour "Viens ici", Spike doit TOUJOURS partir de la droite (-200)
      // On force le reset de position pour garantir la cohérence
      const startPosition = -200;
      const windowWidth = window.innerWidth;
      const dogWidth = 200;
      const margin = 50;
      const targetPosition = Math.random() * (windowWidth - dogWidth - 2 * margin) + margin;
      
      console.log(`RESET pour Viens ici: position actuelle ${currentPosition.right} → position de départ ${startPosition}`);
      console.log(`Position cible: ${targetPosition}`);
      
      // Reset complet de la position de départ
      currentPosition.right = startPosition;
      dog.style.right = `${startPosition}px`;
      dog.style.animation = 'none'; // Annule toute animation en cours
      
      // Maintenant créer l'animation avec la position correcte
      const duration = createRunAnimation(targetPosition);
      changeState('course', startPosition, targetPosition);
      
      console.log(`Viens ici: course de droite (${startPosition}) vers position ${targetPosition}`);
      
      dog.style.animation = `run-to-position ${duration / 1000}s linear`;
      
      setTimeout(() => {
        dog.classList.remove('running');
        dog.style.animation = 'none';
        currentPosition.right = targetPosition;
        dog.style.right = `${targetPosition}px`;
        
        // Phase 2: Transition vers la marche
        continueInteractiveSequence();
      }, duration);
    }

    function continueInteractiveSequence() {
      if (!isInteractiveMode) return;
      
      const nextState = getNextState(currentState);
      
      console.log(`Transition vers ${nextState}`);
      
      if (nextState === 'marche') {
        // Se déplacer pendant la marche avec gestion du demi-tour
        const newPosition = getRandomPosition();
        executeMovementWithTurning(nextState, newPosition, () => {
          // ✅ CORRECT: Enchaîner directement après le mouvement
          continueInteractiveSequence();
        });
        
      } else if (nextState === 'course') {
        // Course vers une nouvelle position avec gestion du demi-tour
        const newPosition = getRandomPosition();
        executeMovementWithTurning(nextState, newPosition, () => {
          // ✅ CORRECT: Enchaîner directement après le mouvement
          continueInteractiveSequence();
        });
        
      } else {
        // États assis (statiques) - SEULS CES ÉTATS utilisent une pause
        const stateDuration = getRandomDuration(); // 2-15 secondes pour les états assis
        
        dog.classList.remove('running', 'walking');
        dog.classList.add('sitting');
        changeState(nextState, null, null);
        
        console.log(`État assis ${nextState}, attente ${Math.round(stateDuration/1000)}s`);
        setTimeout(() => {
          continueInteractiveSequence();
        }, stateDuration);
      }
    }

    function stopInteractiveMode() {
      // Cette fonction n'est plus utilisée, remplacée par dismissSpike
      console.log('Mode interactif arrêté directement');
      isInteractiveMode = false;
      currentState = 'idle';
      
      if (currentTimeout) {
        clearTimeout(currentTimeout);
      }
      
      // Remettre le chien en position initiale
      dog.classList.remove('running', 'walking', 'sitting');
      dog.style.animation = 'none';
      dog.style.right = '-200px';
      dog.src = states.course_gauche;
      currentPosition.right = -200;
      
      scheduleNextAnimation();
    }

    // Fonctions appelées depuis le main process
    function callSpike() {
      console.log('Spike ! (course simple)');
      if (currentTimeout) {
        clearTimeout(currentTimeout);
      }
      // Lance immédiatement une animation de course simple (ancien comportement)
      startAutomaticAnimation();
    }

    function comeHere() {
      console.log('Viens ici ! (scénario interactif)');
      startInteractiveSequence();
    }

    function dismissSpike() {
      console.log('Oust ! Spike s\'en va...');
      isInteractiveMode = false;
      
      if (currentTimeout) {
        clearTimeout(currentTimeout);
      }
      
      // Vérifier la direction actuelle et l'état
      const currentDirection = getCurrentDirection();
      const isSeated = currentState === 'assis_droit' || currentState === 'assis_respi';
      
      if (currentDirection === 'droite' || isSeated) {
        // Il faut d'abord marcher vers la gauche pendant 1 seconde
        console.log('Demi-tour nécessaire, marche vers la gauche...');
        
        dog.classList.remove('running', 'sitting');
        dog.classList.add('walking');
        
        // Position intermédiaire pour le demi-tour (un peu vers la gauche)
        const intermediatePosition = currentPosition.right + 100; // 100px vers la gauche
        const walkDuration = 1000; // 1 seconde fixe
        
        // Créer animation de marche vers la gauche
        const walkKeyframes = `
          @keyframes turn-around-walk {
            0% { right: ${currentPosition.right}px; }
            100% { right: ${intermediatePosition}px; }
          }
        `;
        
        const oldStyle = document.querySelector('#turn-around-style');
        if (oldStyle) oldStyle.remove();
        
        const style = document.createElement('style');
        style.id = 'turn-around-style';
        style.textContent = walkKeyframes;
        document.head.appendChild(style);
        
        // Marche vers la gauche
        changeState('marche', currentPosition.right, intermediatePosition);
        dog.style.animation = 'turn-around-walk 1s linear';
        
        setTimeout(() => {
          // Après 1 seconde, commence la course vers la sortie
          currentPosition.right = intermediatePosition;
          startExitRun();
        }, walkDuration);
        
      } else {
        // Déjà orienté vers la gauche, course directement
        startExitRun();
      }
    }
    
    function startExitRun() {
      // Course vers la sortie (complètement à gauche de l'écran)
      const exitPosition = window.innerWidth + 200; // Sort complètement de l'écran
      const runDuration = createRunAnimation(exitPosition);
      
      dog.classList.remove('walking', 'sitting');
      dog.classList.add('running');
      
      // Course vers la gauche pour sortir
      changeState('course', currentPosition.right, exitPosition);
      dog.style.animation = `run-to-position ${runDuration / 1000}s linear`;
      
      setTimeout(() => {
        // Une fois sorti, remet en position initiale et retourne au mode automatique
        dog.classList.remove('running');
        dog.style.animation = 'none';
        dog.style.right = '-200px';
        dog.src = states.course_gauche;
        currentPosition.right = -200;
        currentState = 'idle';
        
        console.log('Spike est parti, retour au mode automatique');
        scheduleNextAnimation();
      }, runDuration);
    }

    // Écoute les messages du processus principal
    if (window.electronAPI) {
      window.electronAPI.onCallSpike(() => {
        callSpike();
      });
      
      window.electronAPI.onComeHere(() => {
        comeHere();
      });
      
      // Nouvelle fonction pour "Oust !"
      window.electronAPI.onDismissSpike(() => {
        dismissSpike();
      });
    }

    // Démarre la première animation immédiatement au lancement
    startAutomaticAnimation();
  </script>
</body>
</html>